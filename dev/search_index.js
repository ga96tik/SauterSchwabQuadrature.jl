var documenterSearchIndex = {"docs":
[{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/","page":"API Reference","title":"API Reference","text":"Modules = [SauterSchwabQuadrature]","category":"page"},{"location":"apiref/#SauterSchwabQuadrature.CommonEdge-NTuple{5, Any}","page":"API Reference","title":"SauterSchwabQuadrature.CommonEdge","text":"(::CommonEdge)(f, η1, η2, η3, ξ)\n\nRegularizing coordinate transform for parametrization on the unit triangle.\n\nCommon edge case.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#SauterSchwabQuadrature.CommonEdgeQuad-NTuple{5, Any}","page":"API Reference","title":"SauterSchwabQuadrature.CommonEdgeQuad","text":"(::CommonEdgeQuad)(f, η1, η2, η3, ξ)\n\nRegularizing coordinate transform for parametrization on the unit square: [0,1]² ↦ Γ.\n\nCommon edge case.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#SauterSchwabQuadrature.CommonFace-NTuple{5, Any}","page":"API Reference","title":"SauterSchwabQuadrature.CommonFace","text":"(::CommonFace)(f, η1, η2, η3, ξ)\n\nRegularizing coordinate transform for parametrization on the unit triangle.\n\nCommon face case.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#SauterSchwabQuadrature.CommonFaceQuad-NTuple{5, Any}","page":"API Reference","title":"SauterSchwabQuadrature.CommonFaceQuad","text":"(::CommonFaceQuad)(f, η1, η2, η3, ξ)\n\nRegularizing coordinate transform for parametrization on the unit square: [0,1]² ↦ Γ.\n\nCommon face case.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#SauterSchwabQuadrature.CommonVertex-NTuple{5, Any}","page":"API Reference","title":"SauterSchwabQuadrature.CommonVertex","text":"(::CommonVertex)(f, η1, η2, η3, ξ)\n\nRegularizing coordinate transform for parametrization on the unit triangle.\n\nCommon vertex case.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#SauterSchwabQuadrature.CommonVertexQuad-NTuple{5, Any}","page":"API Reference","title":"SauterSchwabQuadrature.CommonVertexQuad","text":"(::CommonVertexQuad)(f, η1, η2, η3, ξ)\n\nRegularizing coordinate transform for parametrization on the unit square: [0,1]² ↦ Γ.\n\nCommon vertex case.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#SauterSchwabQuadrature.sauterschwab_parameterized-Tuple{Any, SauterSchwabStrategy}","page":"API Reference","title":"SauterSchwabQuadrature.sauterschwab_parameterized","text":"sauterschwab_parameterized(integrand, method::SauterSchwabStrategy)\n\nCompute interaction integrals using the quadrature introduced in [1].\n\nHere, integrand is the pull-back of the integrand into the parametric domain  of the two triangles that define the integration domain. \n\nThe second argument 'strategy' is an object whose type is for triangles one of\n\n- `CommonFace`\n- `CommonEdge`\n- `CommonVertex`\n- `PositiveDistance`\n\nand for quadrilaterals one of\n\n- `CommonFaceQuad`\n- `CommonEdgeQuad`\n- `CommonVertexQuad`\n\naccording to the configuration of the two patches defining the domain of integration.  The constructors of these classes take a single argument acc that defines  the number of quadrature points along each of the four axes of the final  rectangular (ξ,η) integration domain (see [1], Ch 5).\n\nNote that here we use for a planar triangle the representation:\n\nx = x[3] + u*(x[1]-x[3]) + v*(x[2]-x[3])\n\nwith u ranging from 0 to 1 and v ranging from 0 to 1-u. This parameter domain and representation is different from the one used in [1].\n\n[1] Sauter. Schwwab, 'Boundary Element Methods', Springer Berlin Heidelberg, 2011\n\n\n\n\n\n","category":"method"},{"location":"details/#Details","page":"Details","title":"Details","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"The integrals of the form","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"int_Gammaint_Gammab_i(bmx)k(bmxbmy) b_j(bmy)mathrmdS(bmy)mathrmdS(bmx)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"are solved based on relative coordinates.","category":"page"},{"location":"details/#Relative-Coordinates","page":"Details","title":"Relative Coordinates","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"It is assumed that by suitable parameter transforms","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"chi_tau hattau mapsto tau","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"with hattau = (uv) in 01^2 and","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"chi_t hat t mapsto t","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"with hat t = (uv) in 01^2 from the reference element (triangle or square) to the actual ones, the integral is brought into the form","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"iint_hat tauiint_hat t k(chi_tau(uv) chi_t(uv))   mathrmdu mathrmdv mathrmdu mathrmdu ","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"where k(bmxbmy) contains  k, b_i, b_j, and the Jacobi determinant of the parametrization.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"tip: Tip\nThe parametrizations for triangles and quadrilaterals are commonly employed for the integration without regularizations, as well. Hence, they are often already available.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"For the regularizing parametertransform according to [1] four cases are distinguished.","category":"page"},{"location":"details/#Common-Face-Case","page":"Details","title":"Common Face Case","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Gamma and Gamma are equal, and both parameterizations must be equal, that is, chi_t = chi_tau.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"<div align=\"center\">\n<img src=\"../assets/CommonFace.jpg\" width=\"600\"/>\n</div>\n<br/>","category":"page"},{"location":"details/#Common-Edge-Case","page":"Details","title":"Common Edge Case","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Gamma and Gamma have an edge in common, and both parameterizations must fulfill the condition chi_t(s0) = chi_tau(s0). For example, this condition could be met if the points (uin010) and (uin010) are mapped on the same point on the common edge.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"<div align=\"center\">\n<img src=\"../assets/CommonEdge.jpg\" width=\"600\"/>\n</div>\n<br/>","category":"page"},{"location":"details/#Common-Vertex-Case","page":"Details","title":"Common Vertex Case","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Gamma and Gamma have one vertex in common, and both parameterizations must fulfill the condition chi_t(00) = chi_tau(00).  This condition means, that the origin of both reference triangles is mapped on the common vertex.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"<div align=\"center\">\n<img src=\"../assets/CommonVertex.jpg\" width=\"600\"/>\n</div>\n<br/>","category":"page"},{"location":"details/#Positive-Distance-Case","page":"Details","title":"Positive Distance Case","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"The two triangles do not touch at all, and both parameterizations only need to map from the reference triangle onto the real triangle.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"<div align=\"center\">\n<img src=\"../assets/PositiveDistance.jpg\" width=\"600\"/>\n</div>\n<br/>","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Fundamentally, one function is provided:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"sauterschwab_parameterized(integrand, strategy)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The first argument integrand is the parameterized integrand k(chi_tau(uv) chi_t(uv)).  That is, it takes as argument two tuples: ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"integrand((u,v), (u',v'))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The second argument strategy specifies the reparametrization and is one of (the by this package provided) structs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For triangles","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"CommonFace\nCommonEdge\nCommonVertex\nPositiveDistance","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For quadrilaterals","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"CommonFaceQuad\nCommonEdgeQuad\nCommonVertexQuad","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Each such struct takes one argument specifying the quadrature rule, e.g.,","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"strategy = CommonEdge(qrule)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"where qrule is a vector of (point, weight) tuples for a quadrature on the domain 01.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tip: Tip\nWe recommend the FastGaussQuadrature.jl package. For a Gauss-Legendre quadrature a method is provided that maps to the 01 domain:order = 10\nqrule = SauterSchwabQuadrature._legendre(order, 0, 1)","category":"page"},{"location":"Parameterized/#Parameterized","page":"Parameterized","title":"Parameterized","text":"","category":"section"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The called function in this implementation looks like:","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"sauterschwab_parameterized(integrand, method).","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"As on the homepage already mentioned, the user now has to parameterize the integration areas by himself; that means, that integrand is no more the original function that has to be integrated; integrand is now the parameterized version of the original integrand, including the two surface elements of both charts.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"Before the parameterizations/charts (parameterization = chart) are built, the user has to figure out which integration method should be applied, and decide how accurate the integration shall be done. It is recommended, that the user read the page 'Non-Parameterized' before continuing to read here. Because otherwise, he may not be able to apply the concepts of 'integration method' and 'accuracy'.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The parameterization of the sourcetriangle will be called chi_t, and the parameterization of the testtriangle will be called chi_tau. In the following, the parameterization of every single integration method will be presented.","category":"page"},{"location":"Parameterized/#Common-Face","page":"Parameterized","title":"Common Face","text":"","category":"section"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"Gamma and Gamma are equal, and both parameterizations must be equal as well: chi_t(uv) = chi_tau(uv).","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"(Image: )","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The user's task is to find a parameterization which maps the reference triangle (right) onto the real triangle (left). The reference triangle is throughout this package always the same.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The original integrand, which is a function of textbfx and textbfy, becomes:","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"f(chi_tau(uv)chi_t(uv)) cdot fracpartial chi_taupartial utimesfracpartial chi_taupartial v cdotfracpartial chi_tpartial utimesfracpartial chi_tpartial v","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":".","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"This function method as well as the following methods, transform the two area integrals in parameters domain into four 1D integrals from zero to one; therefore, the last argument is created by","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"cf = CommonFace(x).","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"cf is an object of type CommonFace(); x is the number of quadrature points on the integration path 01.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"An example for this case can be found in the commonfaceparameterized.jl file in the examples folder.","category":"page"},{"location":"Parameterized/#Common-Edge","page":"Parameterized","title":"Common Edge","text":"","category":"section"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"Gamma and Gamma have an edge in common, and both parameterizations must fulfill the condition chi_t(s0) = chi_tau(s0). For example, this condition could be met if the points (uin010) and (uin010) are mapped on the same point on the common edge.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"(Image: )","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The modified integrand looks like in the case Common Face.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The last argument can be created by","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"ce = CommonEdge(x).","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"ce is an object of type CommonEdge(); x is the number of quadrature points on the integration path 01.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"An example for this case can be found in the commonedgeparameterized.jl file in the examples folder.","category":"page"},{"location":"Parameterized/#Common-Vertex","page":"Parameterized","title":"Common Vertex","text":"","category":"section"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"Gamma and Gamma have one vertex in common, and both parameterizations must fulfill the condition chi_t(00) = chi_tau(00). This condition means, that the origin of both reference triangles is mapped on the common vertex.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"(Image: )","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The modified integrand looks like in the case Common Face.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The last argument can be created by","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"cv = CommonVertex(x).","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"cv is an object of type CommonVertex(); x is the number of quadrature points on the integration path 01.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"An example for this case can be found in the commonvertexparameterized.jl file in the examples folder.","category":"page"},{"location":"Parameterized/#Positive-Distance","page":"Parameterized","title":"Positive Distance","text":"","category":"section"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The two triangles do not touch at all, and both parameterizations only need to map from the reference triangle onto the real triangle.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"(Image: )","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The modified integrand looks like in the case Common Face.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"The last argument can be created by","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"pd = PositiveDistance(x).","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"pd is an object of type PositiveDistance(); x is the number of quadrature points on the integration path 01.","category":"page"},{"location":"Parameterized/","page":"Parameterized","title":"Parameterized","text":"An example for this case can be found in the positivedistanceparameterized.jl file in the examples folder.","category":"page"},{"location":"Non-Parameterized/#Non-Parameterized","page":"Non-Parameterized","title":"Non-Parameterized","text":"","category":"section"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The called function in this implementation looks like:","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"sauterschwabintegral(sourcechart, testchart, integrand, accuracy, accuracy_pd).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"sourcechart and testchart can be created by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"testchart = simplex(P1,P2,P3); sourcechart = simplex(P4,P5,P6).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The order of the input arguments within the simplex() function does not matter.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"simplex() generates the mapping and needs input arguments of type SVector{3,Float64}; the points P1 to P6 can be created by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"P = point(x,y,z).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"x, y and z are the coordinates of that particular point and point() creates a position vector which is of type SVector{3,Float64}.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The integrand must be defined as a function with two input arguments; the input arguments must be 3D vectors. The name of this function is the input argument.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"Later on, the last argument accuracy will be discussed.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"Since simplex() and point() are functions of CompScienceMeshes, CompScienceMeshes does not just have to be installed on the user's machine, but also be available in the current workspace; the same applies for this package as well. The two packages can be made available by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"using SauterSchwabQuadrature and using CompScienceMeshes.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"These two commands must always be run at the beginning, if using this type of implementation.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"sauterschwabintegral() first modifies testchart and sourcechart with respect to the order of the arguments, within their simplex() functions. Secondly, depending on how many vertices both charts have in common, it generates an object of some type that contains the information of the accuracy and the integration strategy. After all of this has been done, this function will call another function with input arguments of the two modified charts, the original integrand and that new object.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"To understand the arguments accuracy, accuracy_pd and the examples stored in the examples folder, the 'another called function' will be presented next:","category":"page"},{"location":"Non-Parameterized/#Integration","page":"Non-Parameterized","title":"Integration","text":"","category":"section"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"According to item 1 on the homepage, four different constellations of the two triangles are possible:","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"Equal triangles to Common Face\nTwo vertices in common to Common Edge\nOne vertex in common to Common Vertex\nBoth triangles do not touch at all to Positive Distance","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"(Image: )","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"As each of those four constellations has its own integration method (because of a possible singularity in the kernel), the function sauterschwabintegral() has to call another function that handles the situation suitably; hence, it has four methods.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"In the case sauterschwabintegral() has to deal with a situation of the first three cases, the two area-integrals will be transformed to four 1D integrals from zero to one; accuracy gives the number of quadrature points on that integration path, therefore, accuracy is of type unsigned Int64. In the case sauterschwabintegral() has to deal with a situation of the last case, accuracy_pd, which is again of type unsigned Int64, will be considered. It is a rule of how many quadrature points are created on both triangles. accuracy_pd =","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"1 to 1\n2 to 3\n3 to 4\n4 to 6\n5 to 7\n6 to 12\n7 to 13\n8 to 36\n9 to 79\n10 to 105\n11 to 120\n12 to 400\n13 to 900","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"quadrature point(s) is(are) created on each triangle.  ","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The user is now able to understand the examples in the '...non_parameterized.jl' files, or rather their titles. The order of the points within the two simplex() functions of Sourcechart and Testchart can be changed arbitrarily, the result will always remain the same. For those, who are interested in the 'called function', or want to skip sauterschwabintegral() and call the integration directly, which is actually only a sorting process, may read on now.  ","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The called function by sauterschwabintegral() is:","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"sauterschwab_nonparameterized(sourcechart, testchart, integrand, method).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"sourcechart and testchart are the modified versions of the original charts; integrand is the same as at the beginning, and method is that created object. The type of method is responsible for what method of sauterschwab_nonparameterized is chosen. The four methods will be listed now:","category":"page"},{"location":"Non-Parameterized/#Common-Face","page":"Non-Parameterized","title":"Common Face","text":"","category":"section"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"Gamma and Gamma are equal; hence, sourcechart and testchart are equal as well. The two charts have to be created by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"testchart = sourcechart = simplex(P1,P2,P3);","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"where, P1, P2 and P3 are the vertices of that particular triangle. Note, that both charts must be equal, which means that the first argument of both charts must be equal, the second argument of both charts must be equal, and the last argument of both charts must be equal.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The last argument can be created by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"cf = CommonFace(x).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"cf is an object of type CommonFace(); x is the number of quadrature points on the integration path 01.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"An example for this case can be found at the end of the commonfacenon_parameterized.jl file in the examples folder.","category":"page"},{"location":"Non-Parameterized/#Common-Edge","page":"Non-Parameterized","title":"Common Edge","text":"","category":"section"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"Gamma and Gamma are now different; hence, sourcechart and testchart are different as well. The two charts have to be created in the following manner:","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"testchart = simplex(P1,P2,P3); sourcechart = simplex(P1,P4,P3).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"Again, the order of the input arguments must be taken into account: The first argument of both charts must be equal, and the last argument of both charts must be equal. Consequently, the first and the last argument are the vertices which both triangles have in common.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The last argument can be created by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"ce = CommonEdge(x).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"ce is an object of type CommonEdge(); x is the number of quadrature points on the integration path 01.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"An example for this case can be found at the end of the commonedgenon_parameterized.jl file in the examples folder.","category":"page"},{"location":"Non-Parameterized/#Common-Vertex","page":"Non-Parameterized","title":"Common Vertex","text":"","category":"section"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The two triangles and charts are again different. The two charts have to be created in the following manner:","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"sourcechart = simplex(P1,P2,P3); testchart = simplex(P1,P4,P5).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"Again, the order of the input arguments must be taken into account: The first argument of both charts must be equal, the order of P2 and P3 with respect to sourcechart, and the order of P4 and P5 with respect to testchart, does not matter.  Consequently, the first argument is the vertex both triangles have in common.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The last argument is created by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"cv = CommonVertex(x).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"cv is an object of type CommonVertex(); x is the number of quadrature points on the integration path 01.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"An example for this case can be found at the end of the commonvertexnon_parameterized.jl file in the examples folder.","category":"page"},{"location":"Non-Parameterized/#Positive-Distance","page":"Non-Parameterized","title":"Positive Distance","text":"","category":"section"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"As the triangles do not touch at all, the integration can directly be calculated with Gauss´s quadrature. Therefore, the order of the arguments within the two simplex() functions do not matter.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"The last argument can be created by","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"pd = PositiveDistance(x).","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"pd is an object of type PositiveDistance(); x is the rule of how many quadrature points are created on both triangles.","category":"page"},{"location":"Non-Parameterized/","page":"Non-Parameterized","title":"Non-Parameterized","text":"An example for this case can be found at the end of the positivedistancenon_parameterized.jl file in the examples folder.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides the Sauter-Schwab regularizing coordinate transformations [1] such that 4D integrals of the form","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"int_Gammaint_Gammab_i(bmx)k(bmxbmy) b_j(bmy)mathrmdS(bmy)mathrmdS(bmx)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"with Cauchy-singular integral kernels k(bmxbmy) can be integrated via numerical quadrature. The integrals denote double surface integrals over ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"triangles (curved or flat) or \nquadrilaterals (curved or flat) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Gamma and Gamma in 3D Space.  The functions b_i(bmx) and b_i(bmy) are assumed to be real valued and non-singular.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These kind of integrals occur in the area of boundary element methods (BEM) for solving elliptic partial differential equations.  It can be interpreted as the interaction of the two basisfunctions b_i(bmx) and b_i(bmy), with respect to their domains Gamma and Gamma, which, for instance, correspond to the cells of a meshed surface.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"info: Info\nThe triangles or quadrilaterals must be either equal, have two vertices in common, have one vertex in common or do not touch at all. A partial overlap is forbidden.In the current implementation Gamma and Gamma have to be both either triangles or quadrilatersls. However, mixed cases can be implemented, too.","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"[1] Sauter S. Schwab C., \"Boundary Element Methods (Springer Series in Computational Mathematics)\", Chapter 5, Springer, 2010.","category":"page"}]
}
